// DatedOp 1.0 [7-Jun-95 @11:10] (LOCAL) - date and operator id of last change
// Copyright 1994-95 York University [generated by: GenASys (beta) 0.3]
//------------------------------------------------------------------------------
/* <<DBO-ProtectedCode>>RCS[start] */
// $Id: DatedOp.cpp,v 1.5 1998/12/18 00:34:38 ed Exp $
/* <<DBO-ProtectedCode>>RCS[end]   */

#include <sisutil/DatedOp.hpp>
#include <ext/slist>
//#include <sisutil/YUCont.hpp>

//default constructor - REF
DatedOp_REF::DatedOp_REF() : YUDBOBase("DatedOp_REF", dboTLOCAL, dboSTREF) {
    /* <<DBO-ProtectedCode>>Construction-DatedOp_REF[start] */
    myDLC.nullify();
    /* <<DBO-ProtectedCode>>Construction-DatedOp_REF[end]   */
}

//copy constructor - REF
DatedOp_REF::DatedOp_REF(const DatedOp_REF& rDatedOp_REF)
    : YUDBOBase("DatedOp_REF", dboTLOCAL, dboSTREF)
{
    myOperatorId = rDatedOp_REF.myOperatorId;
    myDLC = rDatedOp_REF.myDLC;
}

//assignment operator - REF
DatedOp_REF& DatedOp_REF::operator = (const DatedOp_REF& rDatedOp_REF) {
    myOperatorId = rDatedOp_REF.myOperatorId;
    myDLC = rDatedOp_REF.myDLC;

    return(*this);
}

//equality operator - REF
bool DatedOp_REF::operator == (const DatedOp_REF& rDatedOp_REF) const {
    if (!(myOperatorId == rDatedOp_REF.myOperatorId)) return(0);
    if (!(myDLC == rDatedOp_REF.myDLC)) return(0);

    return(1);
}

void DatedOp_REF::initForQuery() {
}

//accessors - REF
const YUUUID& DatedOp_REF::getOperatorId() const { return(myOperatorId); }

const YUDateTime& DatedOp_REF::getDLC() const { return(myDLC); }

long DatedOp_REF::locateMissingFields() const {
    long lResult = 0;
    if (!lResult && myOperatorId == YUUUID()) lResult = FD_100_OperatorId;
    if (!lResult && myDLC.isNULL()) lResult = FD_100_DLC;
    return(lResult);
}

//mutators - REF
DatedOp_REF& DatedOp_REF::setOperatorId(const YUUUID& rSrc) { myOperatorId = rSrc; return(*this); }
DatedOp_REF& DatedOp_REF::setDLC(const YUDateTime& rSrc) { myDLC = rSrc; return(*this); }

RPCMarshall& operator << (RPCMarshall& rS, const DatedOp_REF& rO) { return(rO.Marsh(rS)); }
RPCMarshall& operator >> (RPCMarshall& rS, DatedOp_REF& rO) { return(rO.UnMarsh(rS)); }
OCIMarshall& operator << (OCIMarshall& rS, const DatedOp_REF& rO) { return(rO.Marsh(rS)); }
OCIMarshall& operator >> (OCIMarshall& rS, DatedOp_REF& rO) { return(rO.UnMarsh(rS)); }
ostream& operator << (ostream& rS, const DatedOp_REF& rO) { return(rO.displayOn(rS)); }

//RPC Marshalling - REF
RPCMarshall& DatedOp_REF::Marsh(RPCMarshall& rS) const {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp_REF::Marsh (RPCMarshall&): called with " << this << ": " << rS << std::endl;
    rS << myOperatorId;
    rS << myDLC;
    return(rS);
}

RPCMarshall& DatedOp_REF::UnMarsh(RPCMarshall& rS) {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp_REF::UnMarsh (RPCMarshall&): called with " << this << ": " << rS << std::endl;
    if (rS.isValid()) rS >> myOperatorId;
    if (rS.isValid()) rS >> myDLC;
    return(rS);
}

//OCI Marshalling - REF
OCIMarshall& DatedOp_REF::Marsh(OCIMarshall& rS) const {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp_REF::Marsh (OCIMarshall&): called with " << this << ": " << rS << std::endl;
    rS << myOperatorId;
    rS << myDLC;
    return(rS);
}

OCIMarshall& DatedOp_REF::UnMarsh(OCIMarshall& rS) {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp_REF::UnMarsh (OCIMarshall&): called with " << this << ": " << rS << std::endl;
    if (rS.isValid()) rS >> myOperatorId;
    if (rS.isValid()) rS >> myDLC;
    return(rS);
}

//delimited fstreamIO - REF
delim_ofstream& operator << (delim_ofstream& rS, const DatedOp_REF& rO) {
    rS << rO.myOperatorId;
    rS << rO.myDLC;
    return(rS);
}

delim_ifstream& operator >> (delim_ifstream& rS, DatedOp_REF& rO) {
    rS >> rO.myOperatorId;
    rS >> rO.myDLC;
    return(rS);
}

//StreamIO - REF
ostream& DatedOp_REF::displayOn(ostream& rS) const {
    rS << "<";
    rS << myOperatorId << "|";
    rS << myDLC;
    rS << ">";
    return(rS);
}

//default constructor
DatedOp::DatedOp() : YUDBOBase("DatedOp", dboTLOCAL, dboSTFULL) {
    /* <<DBO-ProtectedCode>>Construction-DatedOp[start] */
    /* <<DBO-ProtectedCode>>Construction-DatedOp[end]   */
}

//instantiation via reference
DatedOp::DatedOp(const DatedOp_REF& rDatedOp_REF)
    : YUDBOBase("DatedOp", dboTLOCAL, dboSTFULL) {
    myREF = rDatedOp_REF;
}

//copy constructor
DatedOp::DatedOp(const DatedOp& rDatedOp)
    : YUDBOBase("DatedOp", dboTLOCAL, dboSTFULL) {
    myREF = rDatedOp.myREF;
}

//assignment operator
DatedOp& DatedOp::operator = (const DatedOp& rDatedOp) {
    myREF = rDatedOp.myREF;

    return(*this);
}

//equality operator
bool DatedOp::operator == (const DatedOp& rDatedOp) const {
    return(myREF == rDatedOp.myREF);
}

//accessors
const DatedOp_REF& DatedOp::getREF() const { return(myREF); }
const YUUUID& DatedOp::getOperatorId() const { return(myREF.getOperatorId()); }
const YUDateTime& DatedOp::getDLC() const { return(myREF.getDLC()); }

long DatedOp::locateMissingFields() const {
    long lResult = myREF.locateMissingFields();
    return(lResult);
}

//mutators
DatedOp& DatedOp::setREF(const DatedOp_REF& rREF) {
    myREF = rREF;
    return(*this);
}


//RPC Marshalling
RPCMarshall& DatedOp::Marsh(RPCMarshall& rS) const {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp::Marsh (RPCMarshall&): called with " << this << ": " << rS << std::endl;
    rS << myREF;
    return(rS);
}

RPCMarshall& DatedOp::UnMarsh(RPCMarshall& rS) {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp::UMarsh (RPCMarshall&): called with " << this << ": " << rS << std::endl;
    if (rS.isValid()) rS >> myREF;
    //if (!rS.isValid()) return(rS);
    return(rS);
}

//OCI Marshalling
OCIMarshall& DatedOp::Marsh(OCIMarshall& rS) const {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp::Marsh (OCIMarshall&): called with " << this << ": " << rS << std::endl;
    rS << myREF;
    return(rS);
}

OCIMarshall& DatedOp::UnMarsh(OCIMarshall& rS) {
    //if (getenv("SIS_OCI_DEBUG")) std::cerr << "DatedOp::UMarsh (OCIMarshall&): called with " << this << ": " << rS << std::endl;
    if (rS.isValid()) rS >> myREF;
    return(rS);
}

//delimited fstreamIO:
delim_ofstream& operator << (delim_ofstream& rS, const DatedOp& rO) {
    rS << rO.myREF;
    return(rS);
}

delim_ifstream& operator >> (delim_ifstream& rS, DatedOp& rO) {
    rS >> rO.myREF;
    return(rS);
}

//StreamIO
ostream& DatedOp::displayOn(ostream& rS) const {
    rS << "<";
    rS << myREF;
    rS << ">";
    return(rS);
}

//destructor - SET
DatedOp_SET::~DatedOp_SET() {
    Clear();
}

//accessors - SET
long DatedOp_SET::GetCount() const { return(mySet.Count()); }

DatedOp_REF* DatedOp_SET::GetNth(long nPos) const { return(mySet.GetObject(nPos)); }

DatedOp_REF* DatedOp_SET::LocateItem(const DatedOp_REF& rREF) {
    DatedOp_REF* pItem = mySet.First();
    while (pItem) {
        if (*pItem == rREF) return(pItem);
        pItem = mySet.Next();
    }
    return((DatedOp_REF*)NULL);
}

//mutators - SET
void DatedOp_SET::Clear() {
    bValidSet = 0;
    DatedOp_REF* pItem = mySet.First();
    while (pItem) {
        delete pItem;
        pItem = mySet.Next();
    }
    mySet.Clear();
}

DatedOp_REF* DatedOp_SET::ReplaceItem(DatedOp_REF* pOLD, DatedOp_REF* pNEW) {
    return(mySet.Replace(pNEW, pOLD));
}

void DatedOp_SET::DeleteItem(DatedOp_REF* pItem) {
    mySet.Remove(pItem);
    if (pItem) delete pItem;
}

bool DatedOp_SET::Insert(DatedOp_REF* pItem) {
    bValidSet = 1;
    mySet.Insert(pItem, LIST_APPEND);
    return(1);
}

//RPC Marshalling - SET
RPCMarshall& DatedOp_SET::Marsh(RPCMarshall& rS) const {
    YUNumber nItems(YUNumProps(DEFSIZE_SETCOUNT));
    long curItem = 0;
    nItems = GetCount();
    rS << nItems;
    DatedOp_REF* pItem = GetNth(curItem++);
    while (pItem) {
        rS << *pItem;
        pItem = GetNth(curItem++);
    }
    return(rS);
}

RPCMarshall& DatedOp_SET::UnMarsh(RPCMarshall& rS) {
    YUNumber ItemCount(YUNumProps(DEFSIZE_SETCOUNT));
    if (rS.isValid()) rS >> ItemCount;
    long curItem = 0;
    long nItems = ItemCount;
    for (curItem = 0;(curItem < nItems && rS.isValid());curItem++) {
        DatedOp_REF* pItem = new DatedOp_REF;
        rS >> *pItem;
        Insert(pItem);
    }
    return(rS);
}
